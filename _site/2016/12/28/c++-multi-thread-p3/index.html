<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:fb="http://ogp.me/ns/fb#">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta property="og:image" content="/public/photo.jpg" />

    <title>
        
        Introduction to C++ multithread Part 3 &middot; jyt0532's Blog
        
    </title>

    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/poole.css">
    <link rel="stylesheet" href="/public/css/syntax.css">
    <link rel="stylesheet" href="/public/css/hyde.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-89295041-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>


  <body class="theme-base-0f">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          jyt0532's Blog
        </a>
      </h1>
      <p class="lead">learning never ends</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/tag_cloud/">Tag Cloud</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <!--      <a class="sidebar-nav-item" href="https://github.com/jyt0532/archive/v2.1.0.zip">Download</a> -->
      <a class="sidebar-nav-item" href="https://github.com/jyt0532">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Introduction to C++ multithread Part 3</h1>
  <span class="post-date">28 Dec 2016</span>
  <p>lock_guard, unique_lock 教學</p>

<h3 id="problem-with-lockunlock">problem with lock/unlock</h3>

<p>關於上一篇的問題你有答案了嗎 上篇例子用sum++你可能沒有feel 但如果改成一個function的話呢?
沒錯 如果mutex之間的operation噴出了exception</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">funA</span><span class="p">();</span><span class="c1">//if funA throw unexpected exception, the lock will never release
</span>    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p><strong>那噴exception的那個指令之後的指令都不會被跑</strong> 它會直接看它現在是不是在try block裡面
是的話 就會找到相對應的catch block 執行catch block內的指令
找不到的話 就會直接return 再看它的parent function有沒有預期到這個exception 沒有的話就一路return出去
直到找到相對應的exception handler 再去執行相對應的catch 雖然這不是這個文章的主題
但stack unwinding是個很重要的概念
推薦各位看一下learncpp的教學 寫得很好
<a href="http://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/">Exceptions, functions, and stack unwinding</a></p>

<p>回到主題 重點呢 就是如果你噴exception 那麼你的鎖永遠不會release 
其他thread就等你等到死 那怎麼辦呢 簡單 用try/catch包住可能噴exception的所有地方</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="n">funA</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">cException</span><span class="p">){</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">throw</span> <span class="n">cException</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> 
<span class="p">}</span>  </code></pre></figure>

<p>但這樣的寫法只解決的眼前的問題 但當你寫大型的程式的時候 
一個function很可能會有很多個可能的exit point 
那你就必須在所有可能的exit point unlock你的鎖 你的程式就會越來越難maintain</p>

<p>那麼該怎麼讓一個function在結束之前保證release lock呢?</p>

<h3 id="raii">RAII</h3>

<p><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource acquisition is initialization</a></p>

<blockquote>
  <p>In RAII, holding a resource is tied to object lifetime: resource allocation is done during object creation by the constructor, while resource deallocation is done during object destruction by the destructor. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts and to be held only when the object is alive.</p>
</blockquote>

<p>這是個被非常推崇的習慣 特別是C++在處理resource leak或是excpetion safety的時候必須謹記在心的</p>

<p>那C++怎麼implement這件事情呢 剛剛推薦的stack unwinding有看嗎 叫你看你還不看</p>

<p><br /></p>

<p><img src="http://localhost:4000/public/iced.jpeg" alt="Alt text" /></p>

<p>再給你一次機會
<a href="http://stackoverflow.com/questions/2331316/what-is-stack-unwinding">What is stack unwinding</a></p>

<p>借用一下stack overflow <a href="http://stackoverflow.com/users/106671/nikolai-n-fetissov">Nikolai</a>大的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pleak</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// might be lost =&gt; memory leak
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span> <span class="s">"hello world"</span> <span class="p">);</span> <span class="c1">// will be properly destructed
</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span> <span class="s">"boom"</span> <span class="p">);</span>

    <span class="k">delete</span> <span class="p">[]</span> <span class="n">pleak</span><span class="p">;</span> <span class="c1">// will only get here if x == 0. if x!=0, throw exception
</span><span class="p">}</span></code></pre></figure>

<p>C++的compiler會在一個scope要結束的時候(about to go out of scope or exception thrown)去執行所有變數的destructor <strong>in reverse order</strong>
為什麼要相反順序呢 因為後面宣告的變數可能用到之前宣告的變數當作constructor的參數 先destruct後宣告的變數比較安全</p>

<p>所以在multi-thread的世界裡也是一樣 C++為了支援RAII 發明了以下兩個寶貝</p>

<h3 id="lock_guard-unique_lock">lock_guard, unique_lock</h3>

<p>有了lock_guard 世界變得明亮許多</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockGuard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
    <span class="n">funA</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p>簡直完美 要initialize lock_guard 只需要給一個mutex variable 然後呢 剩下的他全幫你搞定
其實內部的實作也是很簡單
lock_guard在constructor裡lock你給他的mutex, 在destructor裡release 同一個mutex 只是他保證destructor會被call到</p>

<p>unique_lock用途又更廣了 除了以上的基本款之外unique_lock還可以拿來當作function的return type
更重要的差別是unique_lock更佳的彈性 支援各種不同的lock</p>

<ol>
  <li>Deferred lock: 先不要acquire 等晚點再aquire</li>
  <li>Time-constrained lock: 試著要lock 但過了一段時間都要不到就放棄</li>
  <li>Recursive lock: 如果一個function會recursively call自己 如果你用的是一般的mutex, 那就會deadlock 因為你的parent正在佔用同樣的鎖 但如果是recursive mutex, 那就可以同一個thread一直acquire同樣的lock, 其他thread必須等到這個thread release 所有的recursive lock之後才可以acquire</li>
  <li>condition variable都需要搭配unique_lock使用</li>
</ol>

<p>有興趣的可以詳讀這篇
<a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-5-flexible-locking.html">Flexible locking with unique_lock&lt;&gt;</a></p>

<p>下一篇進入本系列作的高潮 condition variable</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2017/03/06/https/">
            網路安全(2) - HTTPS
            <small>06 Mar 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2017/02/25/simple-cryptography/">
            網路安全(1) - 基礎密碼學
            <small>25 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2017/02/22/password-security-en/">
            Is your password secure?
            <small>22 Feb 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      
<div id="disqus_thread"></div>
<script>

    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    
    var disqus_config = function () {
        this.page.url = 'https://jyt0532.github.io/2016/12/28/c++-multi-thread-p3/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/12/28/c++-multi-thread-p3'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//https-jyt0532-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    </div>
  </body>
</html>
