<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:fb="http://ogp.me/ns/fb#">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta property="og:image" content="/public/photo.jpg" />

    <title>
        
        jyt0532's Blog &middot; Site Tagline
        
    </title>

    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/poole.css">
    <link rel="stylesheet" href="/public/css/syntax.css">
    <link rel="stylesheet" href="/public/css/hyde.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-89295041-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>


  <body class="theme-base-0f">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          jyt0532's Blog
        </a>
      </h1>
      <p class="lead">learning never ends</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/tag_cloud/">Tag Cloud</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <!--      <a class="sidebar-nav-item" href="https://github.com/jyt0532/archive/v2.1.0.zip">Download</a> -->
      <a class="sidebar-nav-item" href="https://github.com/jyt0532">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2017/01/02/c++-multi-thread-p4-2/">
            Introduction to C++ multithread Part 4-2
        </a>
    </h1>
    
    <p class="post-subtitle">
    condition variable 範例
    </p>
    


    <span class="post-date">02 Jan 2017</span>

    <!--<p>打鐵要趁熱 來看multithread第二常見的example</p>

<h3 id="readwrite-lock">Read/Write Lock</h3>

<p><a href="http://stackoverflow.com/questions/27860685/how-to-make-a-multiple-read-single-write-lock-from-more-basic-synchronization-pr">How to make a multiple-read/single-write lock</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt; 
#include &lt;cstdlib&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">RWLock</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RWLock</span><span class="p">()</span>
            <span class="o">:</span> <span class="n">shared</span><span class="p">()</span>
              <span class="p">,</span> <span class="n">readerQ</span><span class="p">(),</span> <span class="n">writerQ</span><span class="p">()</span>
              <span class="p">,</span> <span class="n">active_readers</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">waiting_writers</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">active_writers</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="n">no_one_writing</span><span class="p">(){</span>
            <span class="k">return</span> <span class="n">active_readers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">no_one_read_and_no_one_write</span><span class="p">(){</span>
            <span class="k">return</span> <span class="n">active_readers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">ReadLock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
            <span class="o">++</span><span class="n">active_readers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">ReadUnlock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">--</span><span class="n">active_readers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
            <span class="n">writerQ</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">WriteLock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">++</span><span class="n">waiting_writers</span><span class="p">;</span>
            <span class="n">writerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_read_and_no_one_write</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
            <span class="o">--</span><span class="n">waiting_writers</span><span class="p">;</span>
            <span class="o">++</span><span class="n">active_writers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">WriteUnlock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">--</span><span class="n">active_writers</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">waiting_writers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">writerQ</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
            <span class="k">else</span>
                <span class="n">readerQ</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">mutex</span>              <span class="n">shared</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">readerQ</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">writerQ</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">active_readers</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">waiting_writers</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">active_writers</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">RWLock</span> <span class="o">&amp;</span><span class="n">rw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteLock</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteUnlock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadLock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadUnlock</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadLock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadUnlock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteLock</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteUnlock</span><span class="p">();</span>

    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">not_safe</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">RWLock</span> <span class="n">rw</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">rw</span><span class="p">),</span> <span class="n">i</span><span class="p">));</span>
        <span class="c1">//threads.push_back(std::thread(not_safe, i));
</span>    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>老話一句 跑起來加速理解</p>

<p><img src="http://localhost:4000/public/imp.gif" alt="Alt text" /></p>

<p>main裡面initiliza一個rw lock
把他丟給所有的thread
注意這裡要用reference丟 這樣所有thread才會用到同一個rw lock</p>

<p>func也簡單 就是要改動result前call WriteLock 改完後call WriteUnlock</p>

<h3 id="readwrite-lock-deep-dive">Read/Write Lock Deep dive</h3>

<p>RWLock這個data structure裡面有一個共用的mutex
跟兩個condition variable readerQ跟writerQ</p>

<p>active_readers, waiting_writers, active_writers 
是紀錄現在的state的變數</p>

<p>基本上就是4個function</p>
<ul>
  <li>ReadLock</li>
  <li>ReadUnlock</li>
  <li>WriteLock</li>
  <li>WriteUnlock</li>
</ul>

<p><strong><em>ReadLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.確認condition 不該做事的話就進CV wait 該做事就往下走 
這裏的寫法只是比較fancy一點 但下列這兩個寫法是等價的</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></code></pre></figure>

<p>第一個寫法是我Part4-1的寫法 對初學者比較好懂 
但要用第二個寫法的話 就把那個function解讀成wait until f
雖然比較難理解但第二個寫法漂亮一些 
就可以把判斷要不要做事的logic寫在另一個function而不是全部塞進while的condition</p>

<p>至於bind和this是什麼意思 有興趣可以詳讀這篇文章
<a href="/2017/01/05/bind/">淺談C++ bind function</a>
在這裏先把它看成</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">no_one_writing</span><span class="p">);</span></code></pre></figure>

<p>3.所以ReadLock要做事的condition 就是沒人在寫或是有人在讀 這個情況下就可以安心進去讀</p>

<p>4.把active_reader++</p>

<p>5.解鎖(optional)</p>

<p><strong><em>ReadUnLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.改變shared data</p>

<p>3.解鎖(optional)</p>

<p>4.去叫writer thread queue的<strong>一個</strong>writer thread起床</p>

<p><strong><em>WriteLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.讓自己先去等waiting_writer++;</p>

<p>3.確認condition 不該做事的話就進CV wait 該做事就往下走
這裏的condition是沒有人讀而且沒有人寫 那我就可以安心write</p>

<p>4.--waiting_writers, ++active_writers, 讓所有人知道有人在寫</p>

<p>5.解鎖(optional)</p>

<p><strong><em>WriteUnLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.改變shared data</p>

<p>3.確認現在的state 如果有writer再等 叫一個writer起床
如果沒有人在等 去叫reader thread queue的<strong>所有</strong>reader thread起床
因為我們默許 多個reader可以同時read 所以就是個部隊起床的概念</p>

<p>4.解鎖(optional)</p>

<p>講解到這邊 我還寫了個不安全的版本 只要把main裡面的第一個for loop改一下thread call的function就可以</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">not_safe</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p><img src="http://localhost:4000/public/areyoureallywithme.gif" alt="Alt text" /></p>

<p>打完收工 問問題時間 如果你夠認真的話 你應該會有兩個問題</p>

<p>Q1. 為什麼ReadUnlock的時候是先解鎖再notify 但WriteUnlock是先notify在解鎖呢</p>

<p>A1. 好問題 因為WriterUnLock在判斷要notify誰的時候 需要access shared data, 所以不能把鎖放掉</p>

<p>Q2. 既然你reader拿鎖的條件 其中一個是active_reader &gt; 0, 那如果reader thread很多的話 很有可能active_reader會一直不為0 writer可能永遠拿不到鎖怎麼辦</p>

<p>A2. Perfect question! 如果你沒念過read/write lock但卻能自己想到這問題 那代表說你極為聰明</p>

<p><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Priority_policies">RW Lock Priority_policies</a></p>

<p>本篇文章的實作是Read-preferring的RW Lock 每當有新的reader進來 他發現有人在read 那他也跟著read 都不管writer受得了受不了</p>

<p><img src="http://localhost:4000/public/dondondon.gif" alt="Alt text" /></p>

<p><strong>所以可能writer會starve</strong></p>

<p>那Write-preferring的RW Lock怎麼改呢 很簡單 就改變reader做事的condition即可</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">no_one_writing</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">waiting_writers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>這樣reader就會等到沒有人寫也沒有人等著寫的時候 才會read 只要有writer來 writer之後的reader都要等</p>

<p>當然你可以定義自己的application想怎麼玩 你也可以在WriterUnlock的時候先判斷有沒有waiting_readers 
有的話先notify_readerQ 或是你可以限定最多同時有多少個reader在read 
隨便你愛怎麼玩就怎麼玩 只是可能需要更多variable記錄現在的state 然後記得要更動這些state variable的時候鎖要拿著就好了</p>

<p>恭喜你已經通透了multi-thread最難的部分 相信之後不論是任何語言的multi-thread問題你都能快速上手</p>

-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2017/01/01/c++-multi-thread-p4/">
            Introduction to C++ multithread Part 4-1
        </a>
    </h1>
    
    <p class="post-subtitle">
    condition variable 教學
    </p>
    


    <span class="post-date">01 Jan 2017</span>

    <!--<p>condition variable 教學</p>

<p><br />
在看Part4之前 先確認你有15分鐘的連續時間
以收到最大效率的學習效果 如果現在沒空也沒關係 
有空再看 我的blog不會拿掉 
但我曾經因為這部分的學習太斷斷續續而走冤枉路</p>

<p>準備好了嗎 Go!</p>

<h3 id="condition-variable是什麼">condition variable是什麼</h3>

<p>之前所有的例子 用的鎖都是 <strong>mut</strong>ual <strong>ex</strong>clusive的lock
其實在正常情況下 我們不會同時只讓一個thread進入critical section</p>

<p>甚至是不同的thread有不同的access條件
比如說 現在critical section是一個文件 
如果是write thread 一次只能一個thread進入critical section修改 
但如果是read thread 一次可以讓很多個thread進去讀 反正你也不會改東西</p>

<p>或者是一個thread想拿東西的時候 發現沒東西可以拿的話就要等
或是一個thread想放東西的時候發現沒地方可以放的話就要等
有太多太多可能的application 需要自己定義做事的condition
這件事要怎麼做到呢 就是用condition variable 我的理解是把它想成一個thread queue</p>

<p>一個thread要做事之前呢 看看有沒有符合可以做事的condition
不符合的話就乖乖push進queue裡面睡覺 等人家叫你醒來
如果有人叫你醒來 你就確認一下有沒有符合可以做事的condition 符合的話就可以做事
不符合就繼續進queue睡覺</p>

<p>有點抽象 以下用一個最最常見的例子講解</p>

<h3 id="producerconsumer">producer/consumer</h3>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt; 
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
#include &lt;deque&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">QueueBuffer</span> <span class="p">{</span>
    <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">not_full</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">not_empty</span><span class="p">;</span>
    <span class="n">QueueBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="o">:</span> <span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">){}</span>
    <span class="kt">void</span> <span class="n">deposit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">){</span>
        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">deq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">){</span>
            <span class="n">not_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>    
        <span class="p">}</span>
        <span class="n">deq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">not_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">fetch</span><span class="p">(){</span>
        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">deq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">not_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">deq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">deq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">not_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">consumer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">QueueBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">fetch</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumer "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" fetched "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">producer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">QueueBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">buffer</span><span class="p">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Produced "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" produced "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">QueueBuffer</span> <span class="n">buffer</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="kr">thread</span> <span class="n">c1</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">c2</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">c3</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">p1</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">p2</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="n">c1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>強烈建議 把上面那段code跑起來 加速理解</p>

<p><br />
<img src="http://localhost:4000/public/doit.gif" alt="Alt text" /></p>

<p>各個擊破 先high level看main
兩個producer 三個consumer共用一個pool
這個pool最多可以放4個東西
producer製造東西 丟進pool
consumer從pool拿東西</p>

<p>再來看consumer跟producer function
再簡單不過 一個call pool的deposit
一個call pool的fetch</p>

<p>現在來看怎麼implement這個Pool</p>

<h3 id="producerconsumer-deep-dive">producer/consumer Deep dive</h3>

<p>QueueBuffer裡面 除了基本的deque放東西 跟capacity以外
需要一個所有thread共用的mutex 跟兩個condition variable
這兩個CV就是thread要被丟進去睡覺的地方
not_full放producer thread, not_empty放consumer thread</p>

<p>來看deposit
一個producer thread先拿到lock之後
<strong>看一下現在的condition 確認一下該做事還是該睡覺</strong>
while裡面的就是等待條件 在這裏 就是如果pool的size滿了就睡覺
not_full.wait(lk) 解讀成把自己push進not_full這個thread queue裡面</p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p>這就是CV最神妙的地方 也是這個系列文最重要的一個概念</p>

<p>而且他並不是一直在while裡面確認condition 
他是一直在CV裡面睡覺直到有人叫他起床
起床之後做幾件事</p>
<ol>
  <li>acquire lock (別懷疑 就是樓上那個unique_lock 我們睡覺前有release它)</li>
  <li>確認while condition符不符合</li>
  <li>是個可以做事的condition的話 跳出while loop 做事</li>
  <li>condition還是不對的話 一樣release剛剛拿的lock 進CV睡覺</li>
</ol>

<p>好如果現在可以做事的話 我就可以把我的data push進pool
然後release lock(看到了嗎 我們在改動shared data的時候 手上一定要有鎖)
最後叫consumer thread queue(not_empty)的其中一個thread起床(notify)
因為你不知道有沒有consumer thread再等你叫他起床 
如果沒有人在not_empty裡面也沒關係 
你再放東西進去pool後就要負責叫not_empty這個CV裡面的thread起床</p>

<p>fetch裡面也大同小異</p>

<p>拿鎖 確認條件 有東西可以拿的話就拿 拿完後release lock
叫producer thread queue的人起床</p>

<p>看到這邊你融會貫通了嗎</p>

<p><img src="http://localhost:4000/public/youweresaying.gif" alt="Alt text" /></p>

<p>如果你夠認真的話 你應該會有個問題</p>

<p>Q. 之前不是有講RAII嗎 為什麼你要call一個lk.unlock() 不call會不會怎麼樣</p>

<p>A. 不會怎麼樣 如同上一篇所講 destructor會unlock 但notify CV的時候 我們並不用拿著鎖
不如先放掉給別人用 所以差別只有performance</p>

<p>請接著看下一個例子
<a href="/2017/01/02/c++-multi-thread-p4-2">Read/Write Lock</a></p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2016/12/28/c++-multi-thread-p3/">
            Introduction to C++ multithread Part 3
        </a>
    </h1>
    
    <p class="post-subtitle">
    lock_guard, unique_lock 教學
    </p>
    


    <span class="post-date">28 Dec 2016</span>

    <!--<p>lock_guard, unique_lock 教學</p>

<h3 id="problem-with-lockunlock">problem with lock/unlock</h3>

<p>關於上一篇的問題你有答案了嗎 上篇例子用sum++你可能沒有feel 但如果改成一個function的話呢?
沒錯 如果mutex之間的operation噴出了exception</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">funA</span><span class="p">();</span><span class="c1">//if funA throw unexpected exception, the lock will never release
</span>    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p><strong>那噴exception的那個指令之後的指令都不會被跑</strong> 它會直接看它現在是不是在try block裡面
是的話 就會找到相對應的catch block 執行catch block內的指令
找不到的話 就會直接return 再看它的parent function有沒有預期到這個exception 沒有的話就一路return出去
直到找到相對應的exception handler 再去執行相對應的catch 雖然這不是這個文章的主題
但stack unwinding是個很重要的概念
推薦各位看一下learncpp的教學 寫得很好
<a href="http://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/">Exceptions, functions, and stack unwinding</a></p>

<p>回到主題 重點呢 就是如果你噴exception 那麼你的鎖永遠不會release 
其他thread就等你等到死 那怎麼辦呢 簡單 用try/catch包住可能噴exception的所有地方</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="n">funA</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">cException</span><span class="p">){</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">throw</span> <span class="n">cException</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> 
<span class="p">}</span>  </code></pre></figure>

<p>但這樣的寫法只解決的眼前的問題 但當你寫大型的程式的時候 
一個function很可能會有很多個可能的exit point 
那你就必須在所有可能的exit point unlock你的鎖 你的程式就會越來越難maintain</p>

<p>那麼該怎麼讓一個function在結束之前保證release lock呢?</p>

<h3 id="raii">RAII</h3>

<p><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource acquisition is initialization</a></p>

<blockquote>
  <p>In RAII, holding a resource is tied to object lifetime: resource allocation is done during object creation by the constructor, while resource deallocation is done during object destruction by the destructor. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts and to be held only when the object is alive.</p>
</blockquote>

<p>這是個被非常推崇的習慣 特別是C++在處理resource leak或是excpetion safety的時候必須謹記在心的</p>

<p>那C++怎麼implement這件事情呢 剛剛推薦的stack unwinding有看嗎 叫你看你還不看</p>

<p><br /></p>

<p><img src="http://localhost:4000/public/iced.jpeg" alt="Alt text" /></p>

<p>再給你一次機會
<a href="http://stackoverflow.com/questions/2331316/what-is-stack-unwinding">What is stack unwinding</a></p>

<p>借用一下stack overflow <a href="http://stackoverflow.com/users/106671/nikolai-n-fetissov">Nikolai</a>大的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pleak</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// might be lost =&gt; memory leak
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span> <span class="s">"hello world"</span> <span class="p">);</span> <span class="c1">// will be properly destructed
</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span> <span class="s">"boom"</span> <span class="p">);</span>

    <span class="k">delete</span> <span class="p">[]</span> <span class="n">pleak</span><span class="p">;</span> <span class="c1">// will only get here if x == 0. if x!=0, throw exception
</span><span class="p">}</span></code></pre></figure>

<p>C++的compiler會在一個scope要結束的時候(about to go out of scope or exception thrown)去執行所有變數的destructor <strong>in reverse order</strong>
為什麼要相反順序呢 因為後面宣告的變數可能用到之前宣告的變數當作constructor的參數 先destruct後宣告的變數比較安全</p>

<p>所以在multi-thread的世界裡也是一樣 C++為了支援RAII 發明了以下兩個寶貝</p>

<h3 id="lock_guard-unique_lock">lock_guard, unique_lock</h3>

<p>有了lock_guard 世界變得明亮許多</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockGuard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
    <span class="n">funA</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p>簡直完美 要initialize lock_guard 只需要給一個mutex variable 然後呢 剩下的他全幫你搞定
其實內部的實作也是很簡單
lock_guard在constructor裡lock你給他的mutex, 在destructor裡release 同一個mutex 只是他保證destructor會被call到</p>

<p>unique_lock用途又更廣了 除了以上的基本款之外unique_lock還可以拿來當作function的return type
更重要的差別是unique_lock更佳的彈性 支援各種不同的lock</p>

<ol>
  <li>Deferred lock: 先不要acquire 等晚點再aquire</li>
  <li>Time-constrained lock: 試著要lock 但過了一段時間都要不到就放棄</li>
  <li>Recursive lock: 如果一個function會recursively call自己 如果你用的是一般的mutex, 那就會deadlock 因為你的parent正在佔用同樣的鎖 但如果是recursive mutex, 那就可以同一個thread一直acquire同樣的lock, 其他thread必須等到這個thread release 所有的recursive lock之後才可以acquire</li>
  <li>condition variable都需要搭配unique_lock使用</li>
</ol>

<p>有興趣的可以詳讀這篇
<a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-5-flexible-locking.html">Flexible locking with unique_lock&lt;&gt;</a></p>

<p>下一篇進入本系列作的高潮 condition variable</p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2016/12/23/c++-multi-thread-p2/">
            Introduction to C++ multithread Part 2
        </a>
    </h1>
    
    <p class="post-subtitle">
    mutex 教學
    </p>
    


    <span class="post-date">23 Dec 2016</span>

    <!--<p>mutex 教學</p>

<h3 id="lock">lock</h3>
<p>恭喜你 現在已經走出十里坡 現在開始來動真格了 
融會貫通才是真本事 
來看一下stackoverflow對於thread和process的比較
<a href="http://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread">What is the difference between a process and a thread?</a></p>

<blockquote>
  <p>Both processes and threads are independent sequences of execution. The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.</p>
</blockquote>

<p>這就是為什麼當你new出很多thread的時候 你必須要非常小心shared data
比如說下面的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">s</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">sum</span><span class="p">)));</span>
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>每次執行結果都會不一樣 偶爾剛好1000偶爾小於1000 原因很簡單 要改變一個變數需要三個步驟</p>

<p>1.register讀變數</p>

<p>2.加一</p>

<p>3.register存回原本address</p>

<p>問題來了 如果某一個thread正在step2, 還沒做到step3的時候 另一個thread 進來做step1, 那最後總數就會小於等於預期的值
所以在處理multi-thread的問題的時候 一定要處理好shared data的access 如果多個thread同時更動同樣data 就會有race condition的問題
這時候就需要鼎鼎大名的mutex來控管操控權限</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Sum</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span> 
    <span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">sum</span><span class="o">++</span><span class="p">;</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>   
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Sum</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">incre</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="n">Sum</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">)));</span>                                                           
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>這裏把sum這個variable跟mutex包在一起 是個比較理想的做法 當然你的mutex要用global variable我也阻止不了你 
可是大家都知道global variable is evil 特別是多線程的program 不想debug到死就要養成好習慣</p>

<p>總結一下 一個thread要改sum variable之前 先去要lock, 如果有人在用 我就一直等 等到鎖被release 如果沒有人在用鎖 我就拿這個鎖  改動資料之後 再把鎖release 看起來相當完美 在shared data(sum) 的前後加lock 任何人都寫得出來 如果面試官問你 這種程式有什麼潛在的問題 你看出來了嗎？</p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2016/12/23/c++-multi-thread-p1/">
            Introduction to C++ multithread Part 1
        </a>
    </h1>
    
    <p class="post-subtitle">
    Thread 基本應用以及語法
    </p>
    


    <span class="post-date">23 Dec 2016</span>

    <!--<p>Thread 基本應用以及語法</p>

<h3 id="為什麼要學multithread">為什麼要學multithread</h3>
<p>我認為在學校念書的時候 沒有什麼機會寫multi-thread的程式 上系統程式比較多琢磨在multi-process 但其實在業界非常常需要處裡多線程的問題 
如果你想在美國找工作 面試很常問的follow up就是你的code要怎麼處理多線程的application 一般的candidate就只知道說 在access shared data前lock, access完之後unlock 
但要如何在面試中脫穎而出就是要看你的實戰經驗 市面上教面試的書大多都是用java教學 我也花了很大的苦心才知道C++怎麼玩多線程 希望把經驗分享一下 讓大家少走一點冤枉路</p>

<h3 id="環境">環境</h3>
<p>本篇的範例只要你有C++11的compiler就可以跑 筆者用4.2.1版本 基本上你用mac 有install Xcode之後應該都可以跑</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt; g++ -std=c++ filename.cpp
</code></pre>
</div>

<h3 id="new-一個thread">New 一個thread</h3>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">thread_function</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am a new thread "</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread_function</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="c1">// without this line, program will abort
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>簡直輕鬆愉快 這裏有一點要注意 
你要把原本的程式想成一個master thread 
他new一個thread出去的時候你必須要等它跑完 自己才能結束掉 
master thread 會在t1.join()那行等t1跑完 才會繼續往下跑 
如果master return 的時候還有thread在跑 整個程式會直接abort 
不過你也可以call detach function
意思就是你跟我再也沒有關係 master就可以放生它自己結束程式</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">thread_function</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am a new thread"</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">usleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This messenge is unlikely to show"</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread_function</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am master thread and I am about to finish"</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="給thread參數">給thread參數</h3>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"test"</span><span class="p">));</span>
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>相當簡單易懂 給thread的第一個參數就是function, 之後就是function的arguments
最後 每個thread有自己的id 可以call this_thread::get_id()取得自己id, 或是call get_id()來得到相對應thread的id</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"test"</span><span class="p">));</span>
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Part1的內容主要是瞭解C++的基本syntax, 下一篇鎖就會進場 儘請期待</p>
-->
  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    
      <a class="pagination-item newer" href="/">Newer</a>
    
  
</div>

      

    </div>
  </body>
</html>
