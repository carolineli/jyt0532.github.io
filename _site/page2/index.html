<!DOCTYPE html>
<html lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:fb="http://ogp.me/ns/fb#">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta property="og:image" content="/public/photo.jpg" />

    <title>
        
        jyt0532's Blog &middot; Site Tagline
        
    </title>

    <!-- CSS -->
    <link rel="stylesheet" href="/public/css/poole.css">
    <link rel="stylesheet" href="/public/css/syntax.css">
    <link rel="stylesheet" href="/public/css/hyde.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/public/favicon.ico">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-89295041-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>


  <body class="theme-base-0f">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          jyt0532's Blog
        </a>
      </h1>
      <p class="lead">learning never ends</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/tag_cloud/">Tag Cloud</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <!--      <a class="sidebar-nav-item" href="https://github.com/jyt0532/archive/v2.1.0.zip">Download</a> -->
      <a class="sidebar-nav-item" href="https://github.com/jyt0532">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2017/01/08/bind/">
            淺談C++ bind function
        </a>
    </h1>
    
    <p class="post-subtitle">
    why, when, how to use bind
    </p>
    


    <span class="post-date">08 Jan 2017</span>

    <!--<p>我們之前在implement<a href="/2017/01/02/c++-multi-thread-p4-2">Read/Write Lock</a>的時候 wait function裡面我們用了bind 我當時輕描淡寫的帶過了 但其實裡面是有些學問的 今天就來把它一探究竟</p>

<p>其實這在很多語言都有 不要因為你不是main c++的就跳過</p>

<p>正文開始 遙想年少輕狂時 曾有這麼一段過去</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span></code></pre></figure>

<p>哇賽 這是什麼東西？</p>

<h3 id="bind">bind</h3>

<p>先從bind開始講起 其實bind只是一個function wrapper</p>

<p>一個例子勝過千言萬語 今天我們有一個很簡單的func 把兩個數加起來</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>    
<span class="p">}</span></code></pre></figure>

<p>如果我們今天想寫一個function always return 1 + 2</p>

<p>我們就不用重複寫一個很像的function然後把裡面的變數寫死</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">add12</span><span class="p">(){</span> 
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>    
<span class="p">}</span></code></pre></figure>

<p>我們直接用一個wrapper把它包起來</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">add12</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add12</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">print</span> <span class="mi">3</span></code></pre></figure>

<p>第一個參數給function pointer, 之後的參數給那個function的參數
看你要怎麼wrap</p>

<p>好處有2</p>

<ol>
  <li>
    <p>Code reusable, 你現在看了沒感覺是因為他只是一個plus 
如果裡面的logic再複雜一點 
你就會發現bind的好處 
你不用把add裡面的東西全copy出來然後寫死你的變數 
事實上很多bug都是這麼來的</p>
  </li>
  <li>
    <p>Easier to maintain, 如果今天變成x+y+1 
你不用去每個function去改 只要改add就好了</p>
  </li>
</ol>

<p>寫了老半天 上面兩點講的好像是同一件事</p>

<p><img src="http://localhost:4000/public/hitme.gif" alt="Alt text" /></p>

<p>總之 bind return一個新的function 
這個新function也可以給參數</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">add2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add2</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">print</span> <span class="mi">8</span></code></pre></figure>

<p>意思就是add2的第一個參數 當成add的第一個參數
參數數量跟順序也不用一定</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">add_second_third_arg</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span> <span class="n">add</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_3</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add_second_third_arg</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">print</span> <span class="mi">7</span></code></pre></figure>

<p><strong>所以訣竅就是 那個要被拿來包的(add) 要寫的通用一點(雖然大多情況是你從外面import的function)
那你bind完包一層之後 就可以customize成適合你application的function</strong></p>

<h3 id="懂了-那回到rw-lock">懂了 那回到RW lock</h3>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">no_one_writing</span><span class="p">(</span><span class="kt">int</span> <span class="n">active_readers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">active_writers</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">active_readers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">RWLock</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">ReadLock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="n">active_readers</span><span class="p">,</span> <span class="n">active_writers</span><span class="p">));</span>
            <span class="o">++</span><span class="n">active_readers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>看完bind教學 我必須把no_one_writing需要的東西用wrapper包給他 看起來挺完美
但這樣不對 因為你active_readers和active_writers都是pass by value
他之後被叫醒 去確認condition的時候會看跟第一次去睡的同一個值 所以你會永遠起來後就睡覺</p>

<p>簡單的修改 改成傳reference就可以</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">active_readers</span><span class="p">),</span> <span class="n">ref</span><span class="p">(</span><span class="n">active_writers</span><span class="p">)));</span></code></pre></figure>

<p>搞定 可是缺點有2</p>

<p>1.在實際的應用上 很有可能你的RW Lock會包成一個library給別人用 所以no_one_writing()應該要屬於我們data structure的一個member function</p>

<p>2.這樣不酷</p>

<p>再回來看一下我們最後的implementation</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span></code></pre></figure>

<p>RWLock::no_one_writing 好懂 就是丟member function給bind的第一個參數 
可是RWLock::no_one_writing 又沒有input參數 你bind的時候給其他參數幹嘛？
這個this又是什麼?</p>

<h3 id="消失的this">消失的this</h3>

<p><a href="http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/">The hidden “this” pointer</a></p>

<p>在一個class的member function裡面 事實上都會比原本的參數再多一個隱藏變數this, this是一個constant pointer指向call這個function的object</p>

<p>learncpp的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Simple</span>
<span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">m_id</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">Simple</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">setID</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">setID</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">int</span> <span class="n">getID</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>compiler會把一個class的member function多一個變數 實際上的setID()的signature變成這樣</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">setID</span><span class="p">(</span><span class="n">Simple</span><span class="o">*</span> <span class="k">const</span> <span class="k">this</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="p">}</span></code></pre></figure>

<p>別人call setID的時候原本是這樣call</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">simple</span><span class="p">.</span><span class="n">setID</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>compiler會解讀成這樣</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">setID</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simple</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>事實上這樣的程式會電腦來說比較簡單 
你就直接把你需要被改變的object address一起當function參數給我
我直接改this的變數的值</p>

<p>Q1: Simple* const this?? const不是不可以變的意思嗎?</p>

<p>A1: const擺在這裡代表this是一個const pointer <strong>代表說這個pointer只能指到一個固定的address 指的地方不能改</strong>
那如果const擺前面 const Simple* this 那就是this的值不能改
再具體一點 如果this是一個房子的地址 前者是地址不能變 後者是房子裡面住的人不能變</p>

<p>Q2: 任何member funciton都有hidden this嗎</p>

<p>A2: 除了static member function之外 static member function就是你不需要有object也可以call的function 既然是這麼定義的 那當然就不會有this pointer</p>

<p>讀到這裡 再回來看一下我們最後的implementation</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span></code></pre></figure>

<p>有沒有比第一次看<a href="/2017/01/02/c++-multi-thread-p4-2">Part4-2</a>的時候有感覺了呢</p>

<p>事實上 no_one_writing還是有吃一個變數this, 所以我們在用wrapper包的時候 
他會預期你要給他一個變數 那是給什麼變數呢 就是給相同的this 也就是這個RW lock本身</p>

<h3 id="c-wait-document">C++ wait document</h3>

<p>通透了之後 大家一起來看一下現在網路上關於wait的doc</p>

<p><a href="http://www.cplusplus.com/reference/condition_variable/condition_variable/wait/">cplusplus.com conditional variable/wait</a></p>

<p><a href="http://en.cppreference.com/w/cpp/thread/condition_variable/wait">cppreference conditional variable/wait</a></p>

<p>恩…看起來作者的要求只有</p>

<p>這個範例code要跑得起來</p>

<p>沒了
看完之後 知道有wait這麼個function 好謝謝再聯絡</p>

<p>當我真的要用wait去實作個read write lock根本不知道該怎麼寫啊
他的mutex跟condition variable居然就用global variable唬攏過去
這你敢信？</p>

<p><img src="http://localhost:4000/public/soft.gif" alt="Alt text" /></p>

<p>沒關係 別怕 有我在 我先幫你把前方未知的路走通了 不只教你wait怎麼用/為什麼用 還教你怎麼在wait的時候 
丟進其他的member function 這麼好的部落格哪裡找</p>

<p>謝謝收看</p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2017/01/02/c++-multi-thread-p4-2/">
            Introduction to C++ multithread Part 4-2
        </a>
    </h1>
    
    <p class="post-subtitle">
    condition variable 範例
    </p>
    


    <span class="post-date">02 Jan 2017</span>

    <!--<p>打鐵要趁熱 來看multithread第二常見的example</p>

<h3 id="readwrite-lock">Read/Write Lock</h3>

<p><a href="http://stackoverflow.com/questions/27860685/how-to-make-a-multiple-read-single-write-lock-from-more-basic-synchronization-pr">How to make a multiple-read/single-write lock</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt; 
#include &lt;cstdlib&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">RWLock</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RWLock</span><span class="p">()</span>
            <span class="o">:</span> <span class="n">shared</span><span class="p">()</span>
              <span class="p">,</span> <span class="n">readerQ</span><span class="p">(),</span> <span class="n">writerQ</span><span class="p">()</span>
              <span class="p">,</span> <span class="n">active_readers</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">waiting_writers</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">active_writers</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>

        <span class="kt">bool</span> <span class="n">no_one_writing</span><span class="p">(){</span>
            <span class="k">return</span> <span class="n">active_readers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">no_one_read_and_no_one_write</span><span class="p">(){</span>
            <span class="k">return</span> <span class="n">active_readers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">ReadLock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_writing</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
            <span class="o">++</span><span class="n">active_readers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">ReadUnlock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">--</span><span class="n">active_readers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
            <span class="n">writerQ</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">WriteLock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">++</span><span class="n">waiting_writers</span><span class="p">;</span>
            <span class="n">writerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RWLock</span><span class="o">::</span><span class="n">no_one_read_and_no_one_write</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
            <span class="o">--</span><span class="n">waiting_writers</span><span class="p">;</span>
            <span class="o">++</span><span class="n">active_writers</span><span class="p">;</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">WriteUnlock</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
            <span class="o">--</span><span class="n">active_writers</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">waiting_writers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">writerQ</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
            <span class="k">else</span>
                <span class="n">readerQ</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
            <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">mutex</span>              <span class="n">shared</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">readerQ</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">writerQ</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">active_readers</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">waiting_writers</span><span class="p">;</span>
        <span class="kt">int</span>                     <span class="n">active_writers</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">RWLock</span> <span class="o">&amp;</span><span class="n">rw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteLock</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteUnlock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadLock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadUnlock</span><span class="p">();</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadLock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">ReadUnlock</span><span class="p">();</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteLock</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">rw</span><span class="p">.</span><span class="n">WriteUnlock</span><span class="p">();</span>

    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">not_safe</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">RWLock</span> <span class="n">rw</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">rw</span><span class="p">),</span> <span class="n">i</span><span class="p">));</span>
        <span class="c1">//threads.push_back(std::thread(not_safe, i));
</span>    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>老話一句 跑起來加速理解</p>

<p><img src="http://localhost:4000/public/imp.gif" alt="Alt text" /></p>

<p>main裡面initiliza一個rw lock
把他丟給所有的thread
注意這裡要用reference丟 這樣所有thread才會用到同一個rw lock</p>

<p>func也簡單 就是要改動result前call WriteLock 改完後call WriteUnlock</p>

<h3 id="readwrite-lock-deep-dive">Read/Write Lock Deep dive</h3>

<p>RWLock這個data structure裡面有一個共用的mutex
跟兩個condition variable readerQ跟writerQ</p>

<p>active_readers, waiting_writers, active_writers 
是紀錄現在的state的變數</p>

<p>基本上就是4個function</p>
<ul>
  <li>ReadLock</li>
  <li>ReadUnlock</li>
  <li>WriteLock</li>
  <li>WriteUnlock</li>
</ul>

<p><strong><em>ReadLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.確認condition 不該做事的話就進CV wait 該做事就往下走 
這裏的寫法只是比較fancy一點 但下列這兩個寫法是等價的</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></code></pre></figure>

<p>第一個寫法是我Part4-1的寫法 對初學者比較好懂 
但要用第二個寫法的話 就把那個function解讀成wait until f
雖然比較難理解但第二個寫法漂亮一些 
就可以把判斷要不要做事的logic寫在另一個function而不是全部塞進while的condition</p>

<p>至於bind和this是什麼意思 有興趣可以詳讀這篇文章
<a href="/2017/01/05/bind/">淺談C++ bind function</a>
在這裏先把它看成</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">readerQ</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">no_one_writing</span><span class="p">);</span></code></pre></figure>

<p>3.所以ReadLock要做事的condition 就是沒人在寫或是有人在讀 這個情況下就可以安心進去讀</p>

<p>4.把active_reader++</p>

<p>5.解鎖(optional)</p>

<p><strong><em>ReadUnLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.改變shared data</p>

<p>3.解鎖(optional)</p>

<p>4.去叫writer thread queue的<strong>一個</strong>writer thread起床</p>

<p><strong><em>WriteLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.讓自己先去等waiting_writer++;</p>

<p>3.確認condition 不該做事的話就進CV wait 該做事就往下走
這裏的condition是沒有人讀而且沒有人寫 那我就可以安心write</p>

<p>4.--waiting_writers, ++active_writers, 讓所有人知道有人在寫</p>

<p>5.解鎖(optional)</p>

<p><strong><em>WriteUnLock:</em></strong></p>

<p>1.Acquire lock</p>

<p>2.改變shared data</p>

<p>3.確認現在的state 如果有writer再等 叫一個writer起床
如果沒有人在等 去叫reader thread queue的<strong>所有</strong>reader thread起床
因為我們默許 多個reader可以同時read 所以就是個部隊起床的概念</p>

<p>4.解鎖(optional)</p>

<p>講解到這邊 我還寫了個不安全的版本 只要把main裡面的第一個for loop改一下thread call的function就可以</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">not_safe</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p><img src="http://localhost:4000/public/areyoureallywithme.gif" alt="Alt text" /></p>

<p>打完收工 問問題時間 如果你夠認真的話 你應該會有兩個問題</p>

<p>Q1. 為什麼ReadUnlock的時候是先解鎖再notify 但WriteUnlock是先notify在解鎖呢</p>

<p>A1. 好問題 因為WriterUnLock在判斷要notify誰的時候 需要access shared data, 所以不能把鎖放掉</p>

<p>Q2. 既然你reader拿鎖的條件 其中一個是active_reader &gt; 0, 那如果reader thread很多的話 很有可能active_reader會一直不為0 writer可能永遠拿不到鎖怎麼辦</p>

<p>A2. Perfect question! 如果你沒念過read/write lock但卻能自己想到這問題 那代表說你極為聰明</p>

<p><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Priority_policies">RW Lock Priority_policies</a></p>

<p>本篇文章的實作是Read-preferring的RW Lock 每當有新的reader進來 他發現有人在read 那他也跟著read 都不管writer受得了受不了</p>

<p><img src="http://localhost:4000/public/dondondon.gif" alt="Alt text" /></p>

<p><strong>所以可能writer會starve</strong></p>

<p>那Write-preferring的RW Lock怎麼改呢 很簡單 就改變reader做事的condition即可</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">no_one_writing</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">waiting_writers</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">active_writers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>這樣reader就會等到沒有人寫也沒有人等著寫的時候 才會read 只要有writer來 writer之後的reader都要等</p>

<p>當然你可以定義自己的application想怎麼玩 你也可以在WriterUnlock的時候先判斷有沒有waiting_readers 
有的話先notify_readerQ 或是你可以限定最多同時有多少個reader在read 
隨便你愛怎麼玩就怎麼玩 只是可能需要更多variable記錄現在的state 然後記得要更動這些state variable的時候鎖要拿著就好了</p>

<p>恭喜你已經通透了multi-thread最難的部分 相信之後不論是任何語言的multi-thread問題你都能快速上手</p>

-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2017/01/01/c++-multi-thread-p4/">
            Introduction to C++ multithread Part 4-1
        </a>
    </h1>
    
    <p class="post-subtitle">
    condition variable 教學
    </p>
    


    <span class="post-date">01 Jan 2017</span>

    <!--<p>condition variable 教學</p>

<p><br />
在看Part4之前 先確認你有15分鐘的連續時間
以收到最大效率的學習效果 如果現在沒空也沒關係 
有空再看 我的blog不會拿掉 
但我曾經因為這部分的學習太斷斷續續而走冤枉路</p>

<p>準備好了嗎 Go!</p>

<h3 id="condition-variable是什麼">condition variable是什麼</h3>

<p>之前所有的例子 用的鎖都是 <strong>mut</strong>ual <strong>ex</strong>clusive的lock
其實在正常情況下 我們不會同時只讓一個thread進入critical section</p>

<p>甚至是不同的thread有不同的access條件
比如說 現在critical section是一個文件 
如果是write thread 一次只能一個thread進入critical section修改 
但如果是read thread 一次可以讓很多個thread進去讀 反正你也不會改東西</p>

<p>或者是一個thread想拿東西的時候 發現沒東西可以拿的話就要等
或是一個thread想放東西的時候發現沒地方可以放的話就要等
有太多太多可能的application 需要自己定義做事的condition
這件事要怎麼做到呢 就是用condition variable 我的理解是把它想成一個thread queue</p>

<p>一個thread要做事之前呢 看看有沒有符合可以做事的condition
不符合的話就乖乖push進queue裡面睡覺 等人家叫你醒來
如果有人叫你醒來 你就確認一下有沒有符合可以做事的condition 符合的話就可以做事
不符合就繼續進queue睡覺</p>

<p>有點抽象 以下用一個最最常見的例子講解</p>

<h3 id="producerconsumer">producer/consumer</h3>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt; 
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
#include &lt;deque&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">QueueBuffer</span> <span class="p">{</span>
    <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">not_full</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">not_empty</span><span class="p">;</span>
    <span class="n">QueueBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="o">:</span> <span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">){}</span>
    <span class="kt">void</span> <span class="n">deposit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">){</span>
        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">deq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">){</span>
            <span class="n">not_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>    
        <span class="p">}</span>
        <span class="n">deq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">not_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">fetch</span><span class="p">(){</span>
        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">deq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">not_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">deq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">deq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">not_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">consumer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">QueueBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">fetch</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumer "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" fetched "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">producer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">QueueBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">buffer</span><span class="p">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Produced "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" produced "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">QueueBuffer</span> <span class="n">buffer</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="kr">thread</span> <span class="n">c1</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">c2</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">c3</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">p1</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kr">thread</span> <span class="n">p2</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="n">c1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>強烈建議 把上面那段code跑起來 加速理解</p>

<p><br />
<img src="http://localhost:4000/public/doit.gif" alt="Alt text" /></p>

<p>各個擊破 先high level看main
兩個producer 三個consumer共用一個pool
這個pool最多可以放4個東西
producer製造東西 丟進pool
consumer從pool拿東西</p>

<p>再來看consumer跟producer function
再簡單不過 一個call pool的deposit
一個call pool的fetch</p>

<p>現在來看怎麼implement這個Pool</p>

<h3 id="producerconsumer-deep-dive">producer/consumer Deep dive</h3>

<p>QueueBuffer裡面 除了基本的deque放東西 跟capacity以外
需要一個所有thread共用的mutex 跟兩個condition variable
這兩個CV就是thread要被丟進去睡覺的地方
not_full放producer thread, not_empty放consumer thread</p>

<p>來看deposit
一個producer thread先拿到lock之後
<strong>看一下現在的condition 確認一下該做事還是該睡覺</strong>
while裡面的就是等待條件 在這裏 就是如果pool的size滿了就睡覺
not_full.wait(lk) 解讀成把自己push進not_full這個thread queue裡面</p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p><strong>在CV裡睡覺之前 release 手中的lock</strong></p>

<p>這就是CV最神妙的地方 也是這個系列文最重要的一個概念</p>

<p>而且他並不是一直在while裡面確認condition 
他是一直在CV裡面睡覺直到有人叫他起床
起床之後做幾件事</p>
<ol>
  <li>acquire lock (別懷疑 就是樓上那個unique_lock 我們睡覺前有release它)</li>
  <li>確認while condition符不符合</li>
  <li>是個可以做事的condition的話 跳出while loop 做事</li>
  <li>condition還是不對的話 一樣release剛剛拿的lock 進CV睡覺</li>
</ol>

<p>好如果現在可以做事的話 我就可以把我的data push進pool
然後release lock(看到了嗎 我們在改動shared data的時候 手上一定要有鎖)
最後叫consumer thread queue(not_empty)的其中一個thread起床(notify)
因為你不知道有沒有consumer thread再等你叫他起床 
如果沒有人在not_empty裡面也沒關係 
你再放東西進去pool後就要負責叫not_empty這個CV裡面的thread起床</p>

<p>fetch裡面也大同小異</p>

<p>拿鎖 確認條件 有東西可以拿的話就拿 拿完後release lock
叫producer thread queue的人起床</p>

<p>看到這邊你融會貫通了嗎</p>

<p><img src="http://localhost:4000/public/youweresaying.gif" alt="Alt text" /></p>

<p>如果你夠認真的話 你應該會有個問題</p>

<p>Q. 之前不是有講RAII嗎 為什麼你要call一個lk.unlock() 不call會不會怎麼樣</p>

<p>A. 不會怎麼樣 如同上一篇所講 destructor會unlock 但notify CV的時候 我們並不用拿著鎖
不如先放掉給別人用 所以差別只有performance</p>

<p>請接著看下一個例子
<a href="/2017/01/02/c++-multi-thread-p4-2">Read/Write Lock</a></p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2016/12/28/c++-multi-thread-p3/">
            Introduction to C++ multithread Part 3
        </a>
    </h1>
    
    <p class="post-subtitle">
    lock_guard, unique_lock 教學
    </p>
    


    <span class="post-date">28 Dec 2016</span>

    <!--<p>lock_guard, unique_lock 教學</p>

<h3 id="problem-with-lockunlock">problem with lock/unlock</h3>

<p>關於上一篇的問題你有答案了嗎 上篇例子用sum++你可能沒有feel 但如果改成一個function的話呢?
沒錯 如果mutex之間的operation噴出了exception</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">funA</span><span class="p">();</span><span class="c1">//if funA throw unexpected exception, the lock will never release
</span>    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p><strong>那噴exception的那個指令之後的指令都不會被跑</strong> 它會直接看它現在是不是在try block裡面
是的話 就會找到相對應的catch block 執行catch block內的指令
找不到的話 就會直接return 再看它的parent function有沒有預期到這個exception 沒有的話就一路return出去
直到找到相對應的exception handler 再去執行相對應的catch 雖然這不是這個文章的主題
但stack unwinding是個很重要的概念
推薦各位看一下learncpp的教學 寫得很好
<a href="http://www.learncpp.com/cpp-tutorial/143-exceptions-functions-and-stack-unwinding/">Exceptions, functions, and stack unwinding</a></p>

<p>回到主題 重點呢 就是如果你噴exception 那麼你的鎖永遠不會release 
其他thread就等你等到死 那怎麼辦呢 簡單 用try/catch包住可能噴exception的所有地方</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="n">funA</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">cException</span><span class="p">){</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">throw</span> <span class="n">cException</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> 
<span class="p">}</span>  </code></pre></figure>

<p>但這樣的寫法只解決的眼前的問題 但當你寫大型的程式的時候 
一個function很可能會有很多個可能的exit point 
那你就必須在所有可能的exit point unlock你的鎖 你的程式就會越來越難maintain</p>

<p>那麼該怎麼讓一個function在結束之前保證release lock呢?</p>

<h3 id="raii">RAII</h3>

<p><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">Resource acquisition is initialization</a></p>

<blockquote>
  <p>In RAII, holding a resource is tied to object lifetime: resource allocation is done during object creation by the constructor, while resource deallocation is done during object destruction by the destructor. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts and to be held only when the object is alive.</p>
</blockquote>

<p>這是個被非常推崇的習慣 特別是C++在處理resource leak或是excpetion safety的時候必須謹記在心的</p>

<p>那C++怎麼implement這件事情呢 剛剛推薦的stack unwinding有看嗎 叫你看你還不看</p>

<p><br /></p>

<p><img src="http://localhost:4000/public/iced.jpeg" alt="Alt text" /></p>

<p>再給你一次機會
<a href="http://stackoverflow.com/questions/2331316/what-is-stack-unwinding">What is stack unwinding</a></p>

<p>借用一下stack overflow <a href="http://stackoverflow.com/users/106671/nikolai-n-fetissov">Nikolai</a>大的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pleak</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// might be lost =&gt; memory leak
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span> <span class="s">"hello world"</span> <span class="p">);</span> <span class="c1">// will be properly destructed
</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span> <span class="s">"boom"</span> <span class="p">);</span>

    <span class="k">delete</span> <span class="p">[]</span> <span class="n">pleak</span><span class="p">;</span> <span class="c1">// will only get here if x == 0. if x!=0, throw exception
</span><span class="p">}</span></code></pre></figure>

<p>C++的compiler會在一個scope要結束的時候(about to go out of scope or exception thrown)去執行所有變數的destructor <strong>in reverse order</strong>
為什麼要相反順序呢 因為後面宣告的變數可能用到之前宣告的變數當作constructor的參數 先destruct後宣告的變數比較安全</p>

<p>所以在multi-thread的世界裡也是一樣 C++為了支援RAII 發明了以下兩個寶貝</p>

<h3 id="lock_guard-unique_lock">lock_guard, unique_lock</h3>

<p>有了lock_guard 世界變得明亮許多</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockGuard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
    <span class="n">funA</span><span class="p">();</span>
<span class="p">}</span>  </code></pre></figure>

<p>簡直完美 要initialize lock_guard 只需要給一個mutex variable 然後呢 剩下的他全幫你搞定
其實內部的實作也是很簡單
lock_guard在constructor裡lock你給他的mutex, 在destructor裡release 同一個mutex 只是他保證destructor會被call到</p>

<p>unique_lock用途又更廣了 除了以上的基本款之外unique_lock還可以拿來當作function的return type
更重要的差別是unique_lock更佳的彈性 支援各種不同的lock</p>

<ol>
  <li>Deferred lock: 先不要acquire 等晚點再aquire</li>
  <li>Time-constrained lock: 試著要lock 但過了一段時間都要不到就放棄</li>
  <li>Recursive lock: 如果一個function會recursively call自己 如果你用的是一般的mutex, 那就會deadlock 因為你的parent正在佔用同樣的鎖 但如果是recursive mutex, 那就可以同一個thread一直acquire同樣的lock, 其他thread必須等到這個thread release 所有的recursive lock之後才可以acquire</li>
  <li>condition variable都需要搭配unique_lock使用</li>
</ol>

<p>有興趣的可以詳讀這篇
<a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-5-flexible-locking.html">Flexible locking with unique_lock&lt;&gt;</a></p>

<p>下一篇進入本系列作的高潮 condition variable</p>
-->
  </div>
  
  <div class="post">
    <h1 class="post-title">
        <a href="/2016/12/23/c++-multi-thread-p2/">
            Introduction to C++ multithread Part 2
        </a>
    </h1>
    
    <p class="post-subtitle">
    mutex 教學
    </p>
    


    <span class="post-date">23 Dec 2016</span>

    <!--<p>mutex 教學</p>

<h3 id="lock">lock</h3>
<p>恭喜你 現在已經走出十里坡 現在開始來動真格了 
融會貫通才是真本事 
來看一下stackoverflow對於thread和process的比較
<a href="http://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread">What is the difference between a process and a thread?</a></p>

<blockquote>
  <p>Both processes and threads are independent sequences of execution. The typical difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.</p>
</blockquote>

<p>這就是為什麼當你new出很多thread的時候 你必須要非常小心shared data
比如說下面的例子</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">s</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">sum</span><span class="p">)));</span>
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>每次執行結果都會不一樣 偶爾剛好1000偶爾小於1000 原因很簡單 要改變一個變數需要三個步驟</p>

<p>1.register讀變數</p>

<p>2.加一</p>

<p>3.register存回原本address</p>

<p>問題來了 如果某一個thread正在step2, 還沒做到step3的時候 另一個thread 進來做step1, 那最後總數就會小於等於預期的值
所以在處理multi-thread的問題的時候 一定要處理好shared data的access 如果多個thread同時更動同樣data 就會有race condition的問題
這時候就需要鼎鼎大名的mutex來控管操控權限</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Sum</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span> 
    <span class="kt">void</span> <span class="n">incre</span><span class="p">(){</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">sum</span><span class="o">++</span><span class="p">;</span>
        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>   
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Sum</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">incre</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="n">Sum</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">)));</span>                                                           
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>   
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>這裏把sum這個variable跟mutex包在一起 是個比較理想的做法 當然你的mutex要用global variable我也阻止不了你 
可是大家都知道global variable is evil 特別是多線程的program 不想debug到死就要養成好習慣</p>

<p>總結一下 一個thread要改sum variable之前 先去要lock, 如果有人在用 我就一直等 等到鎖被release 如果沒有人在用鎖 我就拿這個鎖  改動資料之後 再把鎖release 看起來相當完美 在shared data(sum) 的前後加lock 任何人都寫得出來 如果面試官問你 這種程式有什麼潛在的問題 你看出來了嗎？</p>
-->
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page3">Older</a>
  
  
    
      <a class="pagination-item newer" href="/">Newer</a>
    
  
</div>

      

    </div>
  </body>
</html>
