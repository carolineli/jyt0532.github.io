---
layout: post
title: Design Pattern(10) - Builder
comments: True 
subtitle: design pattern - builder
tags: designPattern
author: jyt0532
---

### 一個constructor參數很多的class

今天我們有一個class Employee
他有很多attribute

{% highlight java %}
public class Employee{
    String name;
    String job;
    String birthday;
    int age;
    int salary;
    String address;
    String phone;
    String email;
    public Employee(String name, String job, String birthday, int age, int salary, String address, String phone, String email){
    	this -> name = name;
    	this -> job = job;
    	this -> birthday = birthday;
    	this -> age = age;
    	this -> salary = salary;
    	this -> address = address;
    	this -> phone = phone;
    	this -> email = email;
    }
}
{% endhighlight %}

![Alt text]({{ site.url }}/public/bulletfly.jpg)

即使你覺得這麼長的constructor沒有問題 可是在創一個物件的時候 有些attribute是必須的 有些是不一定要有的(比如說age跟birthday跟address不一定要提供) 那怎麼辦呢?

寫過Ｃ的都知道 很簡單的default parameter搞定
{% highlight cpp %}
public Employee(String name, String job, String birthday = "N/A", int age = 0, int salary, String address = "N/A", String phone, String email){
    	this -> name = name;
    	this -> job = job;
    	this -> birthday = birthday;
    	this -> age = age;
    	this -> salary = salary;
    	this -> address = address;
    	this -> phone = phone;
    	this -> email = email;
    }
}
{% endhighlight %}

輕鬆 所有optional的值我都先寫好 只需要一個constructor 

但對不起 java有java的玩法 
**java沒有default parameter**

那怎麼辦呢 不好意思 你必須overload你的constructor 

### 題外話 

上面那個C的程式不能那樣寫 所有的optional的參數應該擺在參數的最後面 不可以想擺哪就擺哪

理由是如果今天你擺中間

{% highlight cpp %}
int add(int x = 5, int y){
    return x + y;
}

add(7)//?????
{% endhighlight %}

Compiler不知道你要assign 7給誰

### 回到overload

所以你只能這樣
{% highlight java %}
public class Employee{
    public Employee(String name, String job, int salary, String phone, String email){
    	Employee(name, job, salary, phone, email, "N/A", 0, "N/A");
    }
    public Employee(String name, String job, int salary, String phone, String email, String birthday){
    	Employee(name, job, salary, phone, email, birthday, 0, "N/A");
    }
    public Employee(String name, String job, int salary, String phone, String email, String birthday, int age){
    	Employee(name, job, salary, phone, email, birthday, age, "N/A");
    }

    public Employee(String name, String job, int salary, String phone, String email, String birthday, int age, String address){
    	this -> name = name;
    	this -> job = job;
    	this -> salary = salary;
    	this -> phone = phone;
    	this -> email = email;
    	this -> birthday = birthday;
    	this -> age = age;
    	this -> address = address;
    }
}
{% endhighlight %}

還必須得照重要性排 你無法創一個只有address但沒有birthday跟age的Employee

(你不能多一個只有address沒有birthday和age的constructor 因為他跟只有birthday沒有address和age的constructor有一樣的signature)

福無雙至 禍不單行 缺點還沒說完 即使是上面的實作 還是有缺點 今天如果想改address的default value變成"Not Applicable" 你必須改所有constructor的code

要怎麼解決constructor code重複的問題呢
給你一分鐘
<br><br><br><br><br><br><br>

![Alt text]({{ site.url }}/public/fly.gif)
<br><br><br><br><br><br><br><br><br><br><br><br><br><br>
解答叫做 telescoping constructor

5個參數的constructor 多增加一個參數 call 6個參數的constructor
6個參數的constructor 多增加一個參數 call 7個參數的constructor
7個參數的constructor 多增加一個參數 call 8個參數的constructor

![Alt text]({{ site.url }}/public/builder1.png)
是否覺得有點神似
![Alt text]({{ site.url }}/public/telescope.png)

這樣子你某個optional的argument如果要改 就只要改一個地方

### 回到正題

這實在醜 而且client每次要call都要看一下道理參數順序要怎麼給 而且重要性的問題也還沒解答 
你無法創一個只有address但沒有birthday跟age的Employee

黑暗盡頭 主角登場

我們在Employee裡面加一個inner class, Builder

{% highlight java %}
public class Employee{
    private String name;
    private String job;
    private String birthday;
    private int age;
    private int salary;
    private String address;
    private String phone;
    private String email;
   
    public static class Builder{
	private String name;
	private String job;
    	private int salary;
    	private String phone;
    	private String email;
	private String birthday = "N/A";
    	private int age = 0;
    	private String address = "N/A";
	public Builder(){}
	public Builder setName(String name){
	    this -> name = name;
	    return this;
	}
	public Builder setJob(String job){
	    this -> job = job;
	    return this;
	}
	public Builder setSalary(int salary){
	    this -> salary = salary;
	    return this;
	}
	public Builder setPhone(String phone){
	    this -> phone = phone;
	    return this;
	}
	public Builder setEmail(String email){
	    this -> email = email;
	    return this;
	}
	public Builder setBirthday(String birthday){
	    this -> birthday = birthday;
	    return this;
	}
	public Builder setAge(int age){
	    this -> age = age;
	    return this;
	}
	public Builder setAddress(String address){
	    this -> address = address;
	    return this;
	}
	public Employee build(){
	    return new Employee(this);
	} 

    }
    private Employee(Builder builder){
    	this -> name = builder.name;
    	this -> job = builder.job;
    	this -> salary = builder.salary;
    	this -> phone = builder.phone;
    	this -> email = builder.email;
    	this -> birthday = builder.birthday;
    	this -> age = builder.age;
    	this -> address = builder.address;
    }
}
{% endhighlight %}

client怎麼建一個Employee?

{% highlight cpp %}
Employee e = new Employee.Builder().setName("Alex").setJob("Engineer").setSalary(100).setPhone("123").setEmail("a@b").setAddress("ABC").build();
{% endhighlight %}

對client來說code非常好懂 也解決了之前的問題 我們可以只給address不用給birthday跟age

除此之外 還有什麼好處呢?

1. 對於不合法的輸入及早發現及早治療: 你可以在每一個setter都做好error handling 之前的例子可能你constructor都跑一半了才發現user給你髒東西
這裡的話setter直接噴錯就可以 不用等到build()被call

2. 如果你要給的某個參數是array of something 你需要用到varargs 那你的constructor就無法支援其中兩個參數是array of something的情況 不過這點其實用List<T>也可以解決

3. 如果參數的順序有強制的話 比如給參數A之前 參數B必須已經有了的情況 constructor做不到 可是builder可以輕易做到
### 問問題時間 

Q: 之前說好分離一個物件的創造和使用 factory就是另一個class專門負責創造 為什麼builder需要是inner class?
Q: 之前說好分離一個物件的創造和使用 factory就是另一個class專門負責創造 為什麼builder需要是inner class?

A: 因為constructor是private 我們不想讓其他人去call這個constructor(Builder應該要是唯一可以call constructor的人) 所以Builder是static inner class

Q: 為什麼不能就讓setXXX當成Employee的member function 還特別需要一個Builder? 這樣的話我呼叫完constructor完之後再慢慢set不是也一樣效果嗎?

{% highlight cpp %}
Employee e = new Employee().setName("Alex").setJob("Engineer").setSalary(100).setPhone("123").setEmail("a@b").setAddress("ABC");
{% endhighlight %}

A: 因為可能會有一些invalid state 比如說參數之間有dependency的話 這個做法就不好 另一個缺點是這樣我們無法建造一個**無法被改變狀態的class*

為什麼不set到底就好了 因為會有invalid state
https://stackoverflow.com/questions/997482/does-java-support-default-parameter-values#comment20866457_997883





![Alt text]({{ site.url }}/public/fly2.gif)
### 合成模式

合成模式讓我們將物件合成樹狀結構 呈現 **部分-整體** 的關係 讓外界可以以一致的方式處理這個個別物件或合成物件

### 結構
![Alt text]({{ site.url }}/public/composite1.png)

* Component: 宣告合成的內含物件的介面 所有類別的所有操作**聯集**(包含存取管理Leaf的函式
)
* Leaf(菜): 定義基本物件的行為 不會有子結點

* Composite(菜單): 定義非子節點的行為

* Client: 通過Component介面操作復合物件

### 優缺點

1.簡化client程式碼 用一致的方法去處理復合物件或是個別物件 避免了if-else或是switch

2.可以輕鬆增加Component的類型 新的Composite或是新的Leaf 不需要修改Client

### 討論

基本上合成模式的好處就是client不需要知道你到底是什麼 我都是一樣的方法用你 

要達到這件事 我們就必須有一個uniform的介面給client使用 同時這個介面要包含所有可能節點的所有操作
事實上是挺不安全的(比如說我們根本不想讓一個leaf能夠addLeaf)
這個pattern事實上是以安全性換取了client的便利性


### 合成+反覆器

故事還沒有結束 雖然我們有print function可以讓waiter把所有的菜全部列出來 
但如果菜列到一半 這位認真的服務生突然想上廁所 上完回來想繼續列的時候發現 只能從頭開始列
因為**print的實作是stateless的** 

這時候就需要一個合成的反覆器了 上一篇的反覆器很簡單 因為每個item都是菜 
我只需要用一個index來記錄我列到哪裡就可以 但這裡因為每個物件可能是菜可能是菜單
我們可能目前正在好幾層深的菜單裡 

![Alt text]({{ site.url }}/public/inception.gif)

這裡通常是用stack來實作

{% highlight java %}
public class CompositeIterator implements Iterator<MenuComponent>{
    Stack<Iterator<MenuComponent>> stack = new Stack<Iterator<MenuComponent>>();
   
   public CompositeIterator(Iterator<MenuComponent> iterator){
	stack.push(iterator);
    }
   public MenuComponent next() {
	if (hasNext()) {
    	    Iterator<MenuComponent> iterator = stack.peek();
	    MenuComponent component = iterator.next();
	    stack.push(component.createIterator());
	    return component;
	} else {
	    return null;
	}
    }
   public boolean hasNext() {
	if (stack.empty()) {
	    return false;
	} else {
	    Iterator<MenuComponent> iterator = stack.peek();
	    if (!iterator.hasNext()) {
	    	stack.pop();
	    	return hasNext();
	    } else {
	    	return true;
	    }
	}
    }
}
{% endhighlight %}

![DFS](https://imgs.xkcd.com/comics/dfs.png)


你也可以用queue 這樣印起來就是BFS

