---
layout: post
title: 淺談C++ bind function
comments: True 
subtitle: why, when, how to use bind
tags: c++ 
author: jyt0532
---

我們之前在implement[Read/Write Lock](/2017/01/02/c++-multi-thread-p4-2)的時候 wait function裡面我們用了bind 我當時輕描淡寫的帶過了 但其實裡面是有些學問的 今天就來把它一探究竟

其實這在很多語言都有 不要因為你不是main c++的就跳過

正文開始 遙想年少輕狂時 曾有這麼一段過去
{% highlight cpp %}
readerQ.wait(lk, bind(&RWLock::no_one_writing, this));
{% endhighlight %}

哇賽 這是什麼東西？

### bind

先從bind開始講起 其實bind只是一個function wrapper

一個例子勝過千言萬語 今天我們有一個很簡單的func 把兩個數加起來
{% highlight cpp %}
int add(int x, int y){
    return x + y;    
}
{% endhighlight %}

如果我們今天想寫一個function always return 1 + 2 

我們就不用重複寫一個很像的function然後把裡面的變數寫死
{% highlight cpp %}
int add12(){ 
        return 1 + 2;    
}
{% endhighlight %}
我們直接用一個wrapper把它包起來

{% highlight cpp %}
auto add12 = bind(add, 1, 2);
cout << add12() << endl; // print 3
{% endhighlight %}

第一個參數給function pointer, 之後的參數給那個function的參數
看你要怎麼wrap

好處有2 

1.  Code reusable, 你現在看了沒感覺是因為他只是一個plus 
如果裡面的logic再複雜一點 
你就會發現bind的好處 
你不用把add裡面的東西全copy出來然後寫死你的變數 
事實上很多bug都是這麼來的

2.  Easier to maintain, 如果今天變成x+y+1 
你不用去每個function去改 只要改add就好了

寫了老半天 上面兩點講的好像是同一件事

![Alt text]({{ site.url }}/public/hitme.gif)


總之 bind return一個新的function 
這個function也可以給參數

{% highlight cpp %}
auto add2 = bind(add, placeholders::_1, 2);
cout << add2(6) << endl; // print 8
{% endhighlight %}

意思就是add2的第一個參數 當成add的第一個參數
參數數量跟順序也不用一定

{% highlight cpp %}
auto add_second_third_arg = bind( add, placeholders::_3, placeholders::_2);
cout << add_second_third_arg(6, 4, 3) << endl; // print 7
{% endhighlight %}

**所以訣竅就是 那個要被拿來改的 要寫的通用一點(通常是你import的function)
那你bind完包一層之後 就變成適合你application的function**

那麼現在看回RW lock

### 等等

![Alt text]({{ site.url }}/public/legalhigh.gif)

為什麼這個bind的signature看起來好眼熟啊...
XXXXXXXXXXXXXXXXXXXXXXXXXX

### 懂了 那回到RW lock


{% highlight cpp %}
bool no_one_writing(int active_readers, int active_writers){
    return active_writers == 0 || active_readers > 0;
}
class RWLock {
    public:
        void ReadLock() {
            std::unique_lock<std::mutex> lk(shared);
            readerQ.wait(lk, bind(no_one_writing, active_readers, active_writers));
            ++active_readers;
            lk.unlock();
        }
};
{% endhighlight %}

看完bind教學 我必須把no_one_writing需要的東西用wrapper包給他 看起來挺完美
但這樣不對 因為你active_readers和active_writers都是pass by value
他之後被叫醒 去確認condition的時候會看跟第一次去睡的同一個值 所以你會永遠起來後就睡覺
簡單的修改 改成傳reference就可以

{% highlight cpp %}
readerQ.wait(lk, bind(no_one_writing, ref(active_readers), ref(active_writers)));
{% endhighlight %}

搞定 可是缺點有2

1.在實際的應用上 很有可能你的RW Lock會包成一個library給別人用 所以no_one_writing()應該要屬於我們data structure的一個member function 

2.這樣比較不帥

再回來看一下我們最後的implementation

{% highlight cpp %}
readerQ.wait(lk, bind(&RWLock::no_one_writing, this));
{% endhighlight %}

RWLock::no_one_writing 好懂 就是丟member function給bind的第一個參數 
可是&RWLock::no_one_writing 又沒有input參數 你bind的時候給其他參數幹嘛？
這個this又是什麼?

###消失的this

[The hidden “this” pointer](http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/)


### wait


寫得很差



